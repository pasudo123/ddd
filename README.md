# 도메인 주도 설계 철저 입문 By Kotlin

## 지식을 표현하는 패턴
* 💁 __값 객체 (Value Object)__
  * Equality 로 비교된다. (내부적인 값의 속성을 비교한다.)
  * 불변 특성이 있다.
  * 값의 변경은 새로운 값 객체의 생성이 된다.
* 💁 __엔티티 (Entity)__
  * Identity 로 비교된다. (별도의 식별자가 있다.)
  * 가변 특성이 있다.
    
> 값 객체와 엔티티 간의 구분을 어떻게 하는 것이 좋은가?   
> 생애주기의 존재여부 및 생애주기의 연속성이 있다면 엔티티로 처리하는게 좋다.
> 그 외에는 값 객체로 남겨두는 것이 좋다.

* 생애주기의 존재여부
  * 객체가 태어나서 죽는 경우가 있음을 의미, 시스템 내의 도메인의 정보가 사용되었다가 이후에 사라짐 CREATE/DELETE
* 생애주기의 연속성
  * 생애주기가 계속 반복되는가를 의미, 태어나고 죽고 태어나고 죽고를 반복

> 값 객체도 될 수 있고 엔티티가 될 수있는 모델이 있는 경우   
> 환경에 따라 달라질 수 있으니 충분히 고민을 해봐야 함 (경험적으로 많이 겪어봐야 알 듯)

* 💁 __도메인 서비스__
  * 값 객체로 모든 행동을 구현하지 않고, 별도의 객체로 분리해서 정의할 수 있도록 한다. (별도의 객채 = 도메인 서비스)
    * 도메인 서비스는 값 객체와 엔티티에서 구현되는 `부자연스러움` 을 해결해준다.
  * 도메인 서비스는 별도의 상태값은 가지지 않는다.
  * DDD 에서는 서비스는 두가지 맥락으로 구분된다.
    * 도메인을 위한 서비스
    * 애플리케이션을 위한 서비스
  * 도메인 서비스에서 구현할 지 망설여진다면 우선 `엔티티나 값 객체에 정의해본다.`

## 애플리케이션을 구성하는 패턴
* 💁 __레파지토리__
  * 레파지토리 책임은 객체의 퍼시스턴시까지다.
    * 레파지토리의 책임이 도메인 규칙에 가깝게 책임을 가지고 있는지 살펴야 한다.
    * 레파지토리와 도메인 서비스 책임 둘 중에 `행위` 가 어디에 더 가까운지 알아야 한다.

* 💁 __애플리케이션 서비스__   
<img src="./images/DDD_application_service.png" />
  * `api` -> `application-service` -> `domain-service` -> `repository` -> `data-store`
    * application-service 에서 여러 domain-service 의 내용들을 머지해서 내려주도록 해야한다.
    * 애플리케이션 서비스에 대한 응집도를 낮출수도 혹은 높일수도 있다.
      * 응집도를 낮춘다면,
        * UserApplicationService (유저 등록/탈퇴/수정 을 모두 다 한다.)
      * 응집도를 높인다면, (패키지로 응집도 높인 클래스를 구분한다. application.users.*)
        * UserApplicationRegisterService
        * UserApplicationDeleteService
        * UserApplicationUpdateService
